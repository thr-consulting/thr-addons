<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"FileCleaner.ts.html":{"id":"FileCleaner.ts.html","title":"Source: FileCleaner.ts","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global unzipper Source: FileCleaner.ts import fs from 'fs'; import uniq from 'lodash/uniq'; import pull from 'lodash/pull'; /** Class that records written files and cleans up after */ export default class FileCleaner { _files: string[]; constructor() { this._files = []; } /** * Adds a file to be cleaned * @param filename */ add(filename: string) { this._files.push(filename); } /** * Removes a file to be cleaned * @param filename */ remove(filename) { pull(this._files, filename); } /** * Renames a file * @param a * @param b */ rename(a: string, b: string) { const i = this._files.indexOf(a); if (i &gt;= 0) { this._files[i] = b; } } /** * Removes files, first checking to make sure they exist */ async removeFiles() { // Make sure the array of files are unique this._files = uniq(this._files); await Promise.all(this._files.map(filename =&gt; new Promise((resolve, reject) =&gt; { fs.access(filename, isMissing =&gt; { if (!isMissing) { fs.unlink(filename, err =&gt; { if (err) { reject(err); } else { resolve(); } }); } else { resolve(); } }); }))); this._files = []; } /** * Resets the file cleaner */ reset() { this._files = []; } } × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-07-09T09:30:53-05:00 using the DocStrap template. "},"FileTypeReadStream.ts.html":{"id":"FileTypeReadStream.ts.html","title":"Source: FileTypeReadStream.ts","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global unzipper Source: FileTypeReadStream.ts import fileType from 'file-type'; import {Transform} from 'stream'; /** * @class * Determines the mimetype of a stream. Grabs the minimum number of bytes required to determine * the mimetype. */ export default class FileTypeReadStream extends Transform { _buf: Buffer; _currentLoc: number; mimetype: string; constructor(opts?: {}) { super(opts); this._buf = Buffer.alloc(fileType.minimumBytes); this._currentLoc = 0; this.mimetype = 'application/octet-stream'; } _transform(chunk, enc, cb) { if (this._currentLoc &lt; fileType.minimumBytes) { const bytesNeeded = fileType.minimumBytes - this._currentLoc; const bytesToGrab = Math.min(bytesNeeded, chunk.length); this._buf = Buffer.concat([this._buf.slice(0, this._currentLoc), chunk.slice(0, bytesToGrab)]); this._currentLoc = this._currentLoc + bytesToGrab; } if (this._currentLoc &gt;= fileType.minimumBytes) { const a = fileType(this._buf); if (a) this.mimetype = a.mime; } this.push(chunk); cb(); } } × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-07-09T09:30:53-05:00 using the DocStrap template. "},"SharedCache.ts.html":{"id":"SharedCache.ts.html","title":"Source: SharedCache.ts","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global unzipper Source: SharedCache.ts /* eslint-disable no-underscore-dangle */ import Redis from 'ioredis'; function getRedisKey(prefix: string, key: string): string { return prefix ? `${prefix}:${key}` : key; } function toString(value: any): string { if (value === null) return ''; if (typeof value === 'object') return JSON.stringify(value); return value; } function parse(value: string): {} | null { if (value === '' || value === null) return null; return JSON.parse(value); } export default class SharedCache { /** * Constructs a new SharedCache * @param prefix * @param expire */ constructor({prefix, expire}: {prefix?: string, expire?: number}) { if (process.env.DISABLE_REDIS === 'true') { this._redis = null; } else { this._redis = new Redis({ port: parseInt(process.env.REDIS_PORT || '6379', 10), host: process.env.REDIS_HOST || '127.0.0.1', }); } if (process.env.REDIS_EXPIRE) { this._expire = parseInt(process.env.REDIS_EXPIRE || '0', 10); } else if (expire) { this._expire = expire; } else { this._expire = null; } this._prefix = prefix || ''; } _redis: Redis.Redis | null; _expire: number | null; _prefix: string; /** * Sets a key value pair with optional expiry (in seconds). * @param key * @param data * @param expire * @return {Promise&lt;*&gt;} */ async set(key: string, data: any, expire?: number) { if (!this._redis) return data; const multi = this._redis.multi(); multi.set(getRedisKey(this._prefix, key), toString(data)); if (this._expire || expire) multi.expire(getRedisKey(this._prefix, key), expire || this._expire); return new Promise((resolve, reject) =&gt; { multi.exec(error =&gt; { if (error) reject(error); else resolve(data); }); }); } /** * Gets the value of a key. Returns null if the key does not exist. * @param key * @return {Promise&lt;*&gt;} The value or null. */ async get(key) { if (!this._redis) return null; return parse(await this._redis.get(getRedisKey(this._prefix, key))); } /** * Checks if the key exists in the store. * @param key * @return {Promise&lt;boolean&gt;} Returns true if the key is found, otherwise false. */ async exists(key) { if (!this._redis) return false; return !!await this._redis.exists(getRedisKey(this._prefix, key)); } /** * Removes a key from the store * @param key * @return {Promise&lt;boolean&gt;} True if they key exists and is cleared, otherwise false */ async clear(key) { if (!this._redis) return false; return !!await this._redis.del(getRedisKey(this._prefix, key)); } /** * Clears all keys from the current prefix. * @return {Promise&lt;any&gt;} */ clearAll() { return new Promise((resolve, reject) =&gt; { if (!this._redis) { resolve(); } else { const stream = this._redis.scanStream({match: `${this._prefix}:*`}); stream.on('data', keys =&gt; { if (keys.length) { const pipeline = this._redis.pipeline(); keys.forEach(key =&gt; { pipeline.del(key); }); pipeline.exec(); } }); stream.on('error', reject); stream.on('end', resolve); } }); } } × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-07-09T09:30:53-05:00 using the DocStrap template. "},"TimeoutCounter.ts.html":{"id":"TimeoutCounter.ts.html","title":"Source: TimeoutCounter.ts","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global unzipper Source: TimeoutCounter.ts import {EventEmitter} from 'events'; export default class TimeoutCounter extends EventEmitter { _counter: number; _timeoutDelay: number; _timeoutId: ReturnType&lt;typeof setTimeout&gt;; /** * Initialize a TimeoutCounter with ms delay. * @param timeout */ constructor(timeout = 1000) { super(); this._counter = 0; this._timeoutDelay = timeout; this._timeoutId = setTimeout(this.timeoutHandler, timeout); } /** * Internal function that is called when the timer runs out. */ timeoutHandler = () =&gt; { if (this._counter !== 0) { this._counter = 0; this.emit('timeout'); } }; /** * Increase the counter by one. This also resets the timer. */ add() { this._counter += 1; clearTimeout(this._timeoutId); this._timeoutId = setTimeout(this.timeoutHandler, this._timeoutDelay); this.emit('add', this._counter); } /** * Decrease the counter by one. This also resets the timer. When the last * item is removed, it fires the 'finish' event. */ remove() { if (this._counter &gt; 1) { // Decrement counter clearTimeout(this._timeoutId); this._timeoutId = setTimeout(this.timeoutHandler, this._timeoutDelay); this._counter -= 1; } else if (this._counter === 1) { // Decrement counter to 0, emit finish event this._counter = 0; clearTimeout(this._timeoutId); this.emit('finish'); } } /** * Cancel the timeout counter and reset it. */ cancel() { clearTimeout(this._timeoutId); this._counter = 0; } } × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-07-09T09:30:53-05:00 using the DocStrap template. "},"unzipper.ts.html":{"id":"unzipper.ts.html","title":"Source: unzipper.ts","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global unzipper Source: unzipper.ts import debug from 'debug'; import {Readable} from 'stream'; import {Volume} from 'memfs'; import path from 'path'; import yauzl from 'yauzl'; import ZipReader from './ZipReader'; const d = debug('thx.extras.unzipper'); type OnFileCallback = (fileStreamData: { stream: Readable, filename: string, mimetype?: string, }) =&gt; Promise&lt;void&gt;; /** * Unzips a zip file calling a callback for each file in the zip file. * @param {Readable} zipReadStream - The readable zip file stream. * @param {OnFileCallback} onFile - Called for each file in the zip file. * @return {Promise&lt;void&gt;} Returns a promise when the zip file is complete. */ export default function unzipper(zipReadStream: Readable, onFile: OnFileCallback): Promise&lt;void&gt; { return new Promise((resolveUnzipper, rejectUnzipper) =&gt; { d('Unzipping zip file...'); const mfs = new Volume(); const zipMemWriteStream = mfs.createWriteStream('/zip'); // Event: called when finished writing zip file to memory fs zipMemWriteStream.on('finish', () =&gt; { d(`Finished writing zip to memory. ${zipMemWriteStream.bytesWritten} bytes.`); const zipMemReadStream = new ZipReader(mfs, '/zip'); yauzl.fromRandomAccessReader(zipMemReadStream, zipMemWriteStream.bytesWritten, { autoClose: true, lazyEntries: true, }, (err, zipfile) =&gt; { if (err) { rejectUnzipper(err); return; } d('&gt; Opened zip file from memory'); // Read first entry zipfile.readEntry(); // Event: called when a folder or file is found in a zip file zipfile.on('entry', entry =&gt; { if (/\\/$/.test(entry.fileName)) { // folder entry zipfile.readEntry(); } else { // file entry zipfile.openReadStream(entry, (zerr, zipEntryFileReadStream) =&gt; { if (zerr) throw zerr; d(`&gt; Reading file in zip: ${entry.fileName}`); onFile({ stream: zipEntryFileReadStream, filename: path.basename(entry.fileName), }).then(() =&gt; { zipfile.readEntry(); }); }); } }); // Event: called when the zip file is closed zipfile.on('close', () =&gt; { d('&gt; Zip file closed'); // Remove the zipfile from memory fs and resolve promise resolveUnzipper(); mfs.reset(); }); // Event: called when zip file has an error zipfile.on('error', rejectUnzipper); }); }); // Start piping zip file to memory fs zipReadStream.pipe(zipMemWriteStream); }); } × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-07-09T09:30:53-05:00 using the DocStrap template. "},"ZipReader.ts.html":{"id":"ZipReader.ts.html","title":"Source: ZipReader.ts","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global unzipper Source: ZipReader.ts import {RandomAccessReader} from 'yauzl'; export default class ZipReader extends RandomAccessReader { _fs: any; _file: string; /** * Used to read zip files from any FS like system. * @param fs * @param filename */ constructor(fs, filename) { super(); this._fs = fs; this._file = filename; } _readStreamForRange(start, end) { // log().silly(` readStreamForRange: ${start} - ${end}`); return this._fs.createReadStream(this._file, {start, end: end - 1}); } } × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-07-09T09:30:53-05:00 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global unzipper Global Methods unzipper(zipReadStream, onFile) Unzips a zip file calling a callback for each file in the zip file. Parameters: Name Type Description zipReadStream Readable The readable zip file stream. onFile OnFileCallback Called for each file in the zip file. Source: unzipper.ts, line 16 Returns: Returns a promise when the zip file is complete. Type Promise.&lt;void&gt; × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-07-09T09:30:53-05:00 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global unzipper Classes Classes FileCleaner FileTypeReadStream SharedCache TimeoutCounter ZipReader × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-07-09T09:30:53-05:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global unzipper sidebar_label: Extras title: Extras Extra utilities Install yarn add @thx/extras × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-07-09T09:30:53-05:00 using the DocStrap template. "},"FileCleaner.html":{"id":"FileCleaner.html","title":"Class: FileCleaner","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global unzipper Class: FileCleaner FileCleaner Class that records written files and cleans up after new FileCleaner() Source: FileCleaner.ts, line 18 Methods add(filename) Adds a file to be cleaned Parameters: Name Type Description filename Source: FileCleaner.ts, line 28 remove(filename) Removes a file to be cleaned Parameters: Name Type Description filename Source: FileCleaner.ts, line 37 &lt;async&gt; removeFiles() Removes files, first checking to make sure they exist Source: FileCleaner.ts, line 59 rename(a, b) Renames a file Parameters: Name Type Description a b Source: FileCleaner.ts, line 47 reset() Resets the file cleaner Source: FileCleaner.ts, line 84 × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-07-09T09:30:53-05:00 using the DocStrap template. "},"FileTypeReadStream.html":{"id":"FileTypeReadStream.html","title":"Class: FileTypeReadStream","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global unzipper Class: FileTypeReadStream FileTypeReadStream Determines the mimetype of a stream. Grabs the minimum number of bytes required to determine the mimetype. new FileTypeReadStream() Source: FileTypeReadStream.ts, line 20 × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-07-09T09:30:53-05:00 using the DocStrap template. "},"SharedCache.html":{"id":"SharedCache.html","title":"Class: SharedCache","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global unzipper Class: SharedCache SharedCache new SharedCache(prefix, expire) Constructs a new SharedCache Parameters: Name Type Description prefix expire Source: SharedCache.ts, line 34 Methods &lt;async&gt; clear(key) Removes a key from the store Parameters: Name Type Description key Source: SharedCache.ts, line 111 Returns: True if they key exists and is cleared, otherwise false Type Promise.&lt;boolean&gt; clearAll() Clears all keys from the current prefix. Source: SharedCache.ts, line 121 Returns: Type Promise.&lt;any&gt; &lt;async&gt; exists(key) Checks if the key exists in the store. Parameters: Name Type Description key Source: SharedCache.ts, line 100 Returns: Returns true if the key is found, otherwise false. Type Promise.&lt;boolean&gt; &lt;async&gt; get(key) Gets the value of a key. Returns null if the key does not exist. Parameters: Name Type Description key Source: SharedCache.ts, line 89 Returns: The value or null. Type Promise.&lt;*&gt; &lt;async&gt; set(key, data, expire) Sets a key value pair with optional expiry (in seconds). Parameters: Name Type Description key data expire Source: SharedCache.ts, line 69 Returns: Type Promise.&lt;*&gt; × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-07-09T09:30:53-05:00 using the DocStrap template. "},"TimeoutCounter.html":{"id":"TimeoutCounter.html","title":"Class: TimeoutCounter","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global unzipper Class: TimeoutCounter TimeoutCounter new TimeoutCounter(timeout) Initialize a TimeoutCounter with ms delay. Parameters: Name Type Default Description timeout 1000 Source: TimeoutCounter.ts, line 15 Methods add() Increase the counter by one. This also resets the timer. Source: TimeoutCounter.ts, line 40 cancel() Cancel the timeout counter and reset it. Source: TimeoutCounter.ts, line 70 remove() Decrease the counter by one. This also resets the timer. When the last item is removed, it fires the 'finish' event. Source: TimeoutCounter.ts, line 52 × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-07-09T09:30:53-05:00 using the DocStrap template. "},"ZipReader.html":{"id":"ZipReader.html","title":"Class: ZipReader","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global unzipper Class: ZipReader ZipReader new ZipReader(fs, filename) Used to read zip files from any FS like system. Parameters: Name Type Description fs filename Source: ZipReader.ts, line 16 × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-07-09T09:30:53-05:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
