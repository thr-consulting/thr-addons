<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"server_fsStuff.ts.html":{"id":"server_fsStuff.ts.html","title":"Source: server/fsStuff.ts","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Source: server/fsStuff.ts import fs from 'fs'; import util from 'util'; import debug from 'debug'; import fmkdirp from 'mkdirp'; import {Readable} from 'stream'; import path from 'path'; import {randomFilename} from '../common/random'; const d = debug('app.lib.fsStuff'); const rdFile = util.promisify(fs.readFile); const wrtFile = util.promisify(fs.writeFile); /** * Promise version of readFile * @param thePath */ export async function readFile(thePath: string): Promise&lt;string&gt; { return rdFile(thePath, 'utf8') .catch(err =&gt; { throw new Error(err); }); } /** * Promise version of writeFile * @param thePath * @param theBuffer */ export async function writeFile(thePath: string, theBuffer: string | Buffer) { return wrtFile(thePath, theBuffer) .catch(err =&gt; { throw new Error(err); }); } /** * Copies a source file to a destination. * @param from * @param to * @return {Promise} */ export async function copyFile(from, to): Promise&lt;void&gt; { return new Promise((resolve, reject) =&gt; { fs.access(from, isMissing =&gt; { if (!isMissing) { fs.copyFile(from, to, err =&gt; { if (err) { reject(err); } else { resolve(); } }); } else { reject(isMissing); } }); }); } /** * Creates a directory path * @param thepath */ export async function mkdirp(thepath: string) { await new Promise((resolve, reject) =&gt; { fmkdirp(thepath, null, err =&gt; { if (err) { reject(err); } else { resolve(); } }); }); } /** * Checks if a file exists * @param {string} thePath * @return {Promise&lt;boolean&gt;} */ export async function fileExists(thePath: string): Promise&lt;boolean&gt; { return new Promise(resolve =&gt; { fs.access(thePath, isMissing =&gt; { if (isMissing) { resolve(false); } else { resolve(true); } }); }); } /** * Promise version of unlink * @param thePath */ export async function rmFile(thePath: string): Promise&lt;void&gt; { return new Promise((resolve, reject) =&gt; { fs.unlink(thePath, err =&gt; { if (err) { reject(err); } else { resolve(); } }); }); } /** * Removes multiple files * @param files */ export async function rmFiles(files: string[]): Promise&lt;void&gt; { await Promise.all(files.map(rmFile)); } /** * Promise version of file writer that writes a stream * @param fname * @param iStream */ export async function writeStream(fname, iStream: Readable) { return new Promise((resolve, reject) =&gt; { const oStream = fs.createWriteStream(fname); oStream.on('close', resolve); oStream.on('error', reject); iStream.on('error', reject); iStream.pipe(oStream); }); } /** * Streams to a random filename in a tmp folder * @param iStream * @param tmpFolder */ export async function streamToTmp(iStream: Readable, tmpFolder: string): Promise&lt;string&gt; { return new Promise((resolve, reject) =&gt; { const fname = path.resolve(tmpFolder, randomFilename()); const oStream = fs.createWriteStream(fname); oStream.on('error', reject); iStream.on('error', reject); iStream.on('close', () =&gt; { resolve(fname); }); iStream.pipe(oStream); }); } /** * Streams multiple streams to tmp files * @param iStreams * @param tmpFolder */ export async function streamsToTmpFiles(iStreams: Readable[], tmpFolder: string): Promise&lt;string[]&gt; { return Promise.all(iStreams.map(stream =&gt; streamToTmp(stream, tmpFolder))); } × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"server_FileCleaner.ts.html":{"id":"server_FileCleaner.ts.html","title":"Source: server/FileCleaner.ts","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Source: server/FileCleaner.ts import debug from 'debug'; import uniq from 'lodash/uniq'; import pull from 'lodash/pull'; import {FileLocationInterface} from './fileLocation/FileLocationInterface'; import {rmFiles} from './fsStuff'; const d = debug('thx.extras.FileCleaner'); /** Class that records written files and cleans up after */ export default class FileCleaner { _files: string[]; _fileLocation: FileLocationInterface | undefined; constructor(fileLocation?: FileLocationInterface) { this._files = []; this._fileLocation = fileLocation; } /** * Adds a file to be cleaned * @param filename */ add(filename: string) { this._files.push(filename); } /** * Removes a file to be cleaned * @param filename */ remove(filename) { pull(this._files, filename); } /** * Renames a file * @param a * @param b */ rename(a: string, b: string) { const i = this._files.indexOf(a); if (i &gt;= 0) { this._files[i] = b; } } /** * Removes files, first checking to make sure they exist */ async removeFiles() { // Make sure the array of files are unique this._files = uniq(this._files); if (this._fileLocation) { await Promise.all(this._files.map(filename =&gt; this._fileLocation.deleteObject(filename))); } else { await rmFiles(this._files); } this._files = []; } /** * Resets the file cleaner */ reset() { this._files = []; } } × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"server_FileTypeReadStream.ts.html":{"id":"server_FileTypeReadStream.ts.html","title":"Source: server/FileTypeReadStream.ts","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Source: server/FileTypeReadStream.ts import fileType from 'file-type'; import {Transform} from 'stream'; /** * @class * Determines the mimetype of a stream. Grabs the minimum number of bytes required to determine * the mimetype. */ export default class FileTypeReadStream extends Transform { _buf: Buffer; _currentLoc: number; mimetype: string; constructor(opts?: {}) { super(opts); this._buf = Buffer.alloc(fileType.minimumBytes); this._currentLoc = 0; this.mimetype = 'application/octet-stream'; } _transform(chunk, enc, cb) { if (this._currentLoc &lt; fileType.minimumBytes) { const bytesNeeded = fileType.minimumBytes - this._currentLoc; const bytesToGrab = Math.min(bytesNeeded, chunk.length); this._buf = Buffer.concat([this._buf.slice(0, this._currentLoc), chunk.slice(0, bytesToGrab)]); this._currentLoc = this._currentLoc + bytesToGrab; } if (this._currentLoc &gt;= fileType.minimumBytes) { const a = fileType(this._buf); if (a) this.mimetype = a.mime; } this.push(chunk); cb(); } } × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"common_mimeCheck.ts.html":{"id":"common_mimeCheck.ts.html","title":"Source: common/mimeCheck.ts","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Source: common/mimeCheck.ts import mime from 'mime-types'; /** * Returns true if the mimetype is a PDF * @param {string} mimetype - The mimetype * @return {boolean} */ export function isPdf(mimetype): boolean { return mimetype === 'application/pdf'; } /** * Returns true if the mimetype is a document. (doc, docx, odt, ods, xlsx, etc) * @param {string} mimetype - The mimetype * @return {boolean} */ export function isDoc(mimetype): boolean { switch (mimetype) { case 'application/msword': case 'application/vnd.ms-excel': case 'application/vnd.oasis.opendocument.text': case 'application/vnd.oasis.opendocument.graphics': case 'application/vnd.oasis.opendocument.spreadsheet': case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': return true; default: return false; } } /** * Returns true if mimetype is a zip file. Does not include 7z, rar, etc. * @param {string} mimetype - The mimetype * @return {boolean} */ export function isZip(mimetype): boolean { switch (mimetype) { case 'application/x-zip-compressed': case 'application/zip': return true; default: return false; } } /** * Returns true if the mimetype is an image * @param {string} mimetype - The mimetype * @return {boolean} */ export function isImage(mimetype): boolean { switch (mimetype) { case 'image/jpeg': case 'image/jpg': case 'image/png': case 'image/gif': case 'image/tif': case 'image/tiff': case 'image/bmp': case 'image/*': // This is not a valid mimetype, but it is used for images sometimes return true; default: return false; } } export function isJpg(mimetype): boolean { return mimetype === 'image/jpeg'; } /** * Returns true if we support the mimetype * @param {string} mimetype - The mimetype * @return {boolean} */ export function isMimetypeSupported(mimetype): boolean { return isPdf(mimetype) || isDoc(mimetype) || isImage(mimetype); } export function mimetypeFromFilename(filename) { return mime.lookup(filename); } export function extFromMimetype(mimetype) { return mime.extension(mimetype); } × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"server_SharedCache.ts.html":{"id":"server_SharedCache.ts.html","title":"Source: server/SharedCache.ts","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Source: server/SharedCache.ts import {promisify} from 'util'; /* eslint-disable no-underscore-dangle */ function getRedisKey(prefix: string, key: string): string { return prefix ? `${prefix}:${key}` : key; } function toString(value: any): string { if (value === null) return ''; if (typeof value === 'object') return JSON.stringify(value); return value; } function parse(value: string): {} | null { if (value === '' || value === null) return null; return JSON.parse(value); } export default class SharedCache { /** * Constructs a new SharedCache * @param redis * @param prefix * @param expire */ constructor({redis, prefix, expire}: {redis?: any, prefix?: string, expire?: number}) { if (redis) { this._redis = { get: promisify(redis.get).bind(redis), set: promisify(redis.set).bind(redis), exists: promisify(redis.exists).bind(redis), del: promisify(redis.del).bind(redis), scan: promisify(redis.scan).bind(redis), }; } if (expire) { this._expire = expire; } else { this._expire = null; } this._prefix = prefix || ''; } _redis: any | null; _expire: number | null; _prefix: string; /** * Sets a key value pair with optional expiry (in seconds). * @param key * @param data * @param expire * @return {Promise&lt;*&gt;} */ async set(key: string, data: any, expire?: number) { if (!this._redis) return data; if (this._expire || expire) { await this._redis.set(getRedisKey(this._prefix, key), toString(data), 'EX', expire || this._expire); } else { await this._redis.set(getRedisKey(this._prefix, key), toString(data)); } return data; } /** * Gets the value of a key. Returns null if the key does not exist. * @param key * @return {Promise&lt;*&gt;} The value or null. */ async get(key) { if (!this._redis) return null; return parse(await this._redis.get(getRedisKey(this._prefix, key))); } /** * Checks if the key exists in the store. * @param key * @return {Promise&lt;boolean&gt;} Returns true if the key is found, otherwise false. */ async exists(key) { if (!this._redis) return false; return !!await this._redis.exists(getRedisKey(this._prefix, key)); } /** * Removes a key from the store * @param key * @return {Promise&lt;boolean&gt;} True if they key exists and is cleared, otherwise false */ async clear(key) { if (!this._redis) return false; return !!await this._redis.del(getRedisKey(this._prefix, key)); } } × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"server_fileLocation_Spaces.ts.html":{"id":"server_fileLocation_Spaces.ts.html","title":"Source: server/fileLocation/Spaces.ts","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Source: server/fileLocation/Spaces.ts import debug from 'debug'; import AWS from 'aws-sdk'; import find from 'lodash/find'; import path from 'path'; import {FileLocationInterface} from './FileLocationInterface'; const d = debug('app.docs.Spaces'); export default class Spaces implements FileLocationInterface { _spaces: AWS.S3; _bucket: string; _basePath: string; constructor({endpoint, accessKey, secret, bucket, basePath}: {endpoint: string, accessKey: string, secret: string, bucket: string, basePath?: string}) { // @ts-ignore this._spaces = new AWS.S3({ endpoint: new AWS.Endpoint(endpoint), accessKeyId: accessKey, secretAccessKey: secret, }); this._bucket = bucket; this._basePath = basePath || ''; // Create bucket if it doesn't exist this.createBucket(this._bucket, 'private', true); } /** * Creates a new bucket * @param bucket * @param acl - Either `private` or `public-read` * @param checkIfExists */ async createBucket(bucket, acl = 'private', checkIfExists = false) { if (checkIfExists) { const buckets = await this._spaces.listBuckets().promise(); const checkBucket = find(buckets.Buckets, {Name: bucket}); if (checkBucket) return; } await this._spaces.createBucket({ Bucket: bucket, ACL: acl, }).promise(); } async putObject(name, stream, mimetype) { await this._spaces.upload({ Bucket: this._bucket, Key: this.getFullName(name), Body: stream, ContentType: mimetype || undefined, // 'application/pdf', }).promise(); } getObject(name) { return this._spaces.getObject({ Bucket: this._bucket, Key: this.getFullName(name), }).createReadStream(); } async deleteObject(name) { await this._spaces.deleteObject({ Bucket: this._bucket, Key: this.getFullName(name), }).promise(); } getObjectUrl(name, {expires} = {expires: 60}) { return this._spaces.getSignedUrl('getObject', { Bucket: this._bucket, Key: this.getFullName(name), Expires: expires, }); } putObjectUrl(name, mimetype?: string, {expires} = {expires: 60}) { return this._spaces.getSignedUrl('putObject', { Bucket: this._bucket, Key: this.getFullName(name), Expires: expires, ContentType: mimetype || undefined, // 'application/pdf', }); } async objectExists(name) { try { await this._spaces.headObject({ Bucket: this._bucket, Key: this.getFullName(name), }).promise(); return true; } catch (err) { if (err.statusCode === 404) return false; throw err; } } getFullName(name: string): string { return path.join(this._basePath, name); } locationType(): string { return 'spaces'; } } × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"server_TimeoutCounter.ts.html":{"id":"server_TimeoutCounter.ts.html","title":"Source: server/TimeoutCounter.ts","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Source: server/TimeoutCounter.ts import {EventEmitter} from 'events'; export default class TimeoutCounter extends EventEmitter { _counter: number; _timeoutDelay: number; _timeoutId: ReturnType&lt;typeof setTimeout&gt;; /** * Initialize a TimeoutCounter with ms delay. * @param timeout */ constructor(timeout = 1000) { super(); this._counter = 0; this._timeoutDelay = timeout; this._timeoutId = setTimeout(this.timeoutHandler, timeout); } /** * Internal function that is called when the timer runs out. */ timeoutHandler = () =&gt; { if (this._counter !== 0) { this._counter = 0; this.emit('timeout'); } }; /** * Increase the counter by one. This also resets the timer. */ add() { this._counter += 1; clearTimeout(this._timeoutId); this._timeoutId = setTimeout(this.timeoutHandler, this._timeoutDelay); this.emit('add', this._counter); } /** * Decrease the counter by one. This also resets the timer. When the last * item is removed, it fires the 'finish' event. */ remove() { if (this._counter &gt; 1) { // Decrement counter clearTimeout(this._timeoutId); this._timeoutId = setTimeout(this.timeoutHandler, this._timeoutDelay); this._counter -= 1; } else if (this._counter === 1) { // Decrement counter to 0, emit finish event this._counter = 0; clearTimeout(this._timeoutId); this.emit('finish'); } } /** * Cancel the timeout counter and reset it. */ cancel() { clearTimeout(this._timeoutId); this._counter = 0; } } × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"server_unzipper.ts.html":{"id":"server_unzipper.ts.html","title":"Source: server/unzipper.ts","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Source: server/unzipper.ts import debug from 'debug'; import {Readable} from 'stream'; import {Volume} from 'memfs'; import path from 'path'; import yauzl from 'yauzl'; import ZipReader from './ZipReader'; const d = debug('thx.extras.unzipper'); type OnFileCallback = (fileStreamData: { stream: Readable, filename: string, mimetype?: string, }) =&gt; Promise&lt;void&gt;; /** * Unzips a zip file calling a callback for each file in the zip file. * @param {Readable} zipReadStream - The readable zip file stream. * @param {OnFileCallback} onFile - Called for each file in the zip file. * @return {Promise&lt;void&gt;} Returns a promise when the zip file is complete. */ export default function unzipper(zipReadStream: Readable, onFile: OnFileCallback): Promise&lt;void&gt; { return new Promise((resolveUnzipper, rejectUnzipper) =&gt; { d('Unzipping zip file...'); const mfs = new Volume(); const zipMemWriteStream = mfs.createWriteStream('/zip'); // Event: called when finished writing zip file to memory fs zipMemWriteStream.on('finish', () =&gt; { d(`Finished writing zip to memory. ${zipMemWriteStream.bytesWritten} bytes.`); const zipMemReadStream = new ZipReader(mfs, '/zip'); yauzl.fromRandomAccessReader(zipMemReadStream, zipMemWriteStream.bytesWritten, { autoClose: true, lazyEntries: true, }, (err, zipfile) =&gt; { if (err) { rejectUnzipper(err); return; } d('&gt; Opened zip file from memory'); // Read first entry zipfile.readEntry(); // Event: called when a folder or file is found in a zip file zipfile.on('entry', entry =&gt; { if (/\\/$/.test(entry.fileName)) { // folder entry zipfile.readEntry(); } else { // file entry zipfile.openReadStream(entry, (zerr, zipEntryFileReadStream) =&gt; { if (zerr) throw zerr; d(`&gt; Reading file in zip: ${entry.fileName}`); onFile({ stream: zipEntryFileReadStream, filename: path.basename(entry.fileName), }).then(() =&gt; { zipfile.readEntry(); }); }); } }); // Event: called when the zip file is closed zipfile.on('close', () =&gt; { d('&gt; Zip file closed'); // Remove the zipfile from memory fs and resolve promise resolveUnzipper(); mfs.reset(); }); // Event: called when zip file has an error zipfile.on('error', rejectUnzipper); }); }); // Start piping zip file to memory fs zipReadStream.pipe(zipMemWriteStream); }); } × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"server_ZipReader.ts.html":{"id":"server_ZipReader.ts.html","title":"Source: server/ZipReader.ts","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Source: server/ZipReader.ts import {RandomAccessReader} from 'yauzl'; export default class ZipReader extends RandomAccessReader { _fs: any; _file: string; /** * Used to read zip files from any FS like system. * @param fs * @param filename */ constructor(fs, filename) { super(); this._fs = fs; this._file = filename; } _readStreamForRange(start, end) { // log().silly(` readStreamForRange: ${start} - ${end}`); return this._fs.createReadStream(this._file, {start, end: end - 1}); } } × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"global.html":{"id":"global.html","title":"Global","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Global Methods &lt;async&gt; copyFile(from, to) Copies a source file to a destination. Parameters: Name Type Description from to Source: server/fsStuff.ts, line 33 Returns: Type Promise &lt;async&gt; fileExists(thePath) Checks if a file exists Parameters: Name Type Description thePath string Source: server/fsStuff.ts, line 73 Returns: Type Promise.&lt;boolean&gt; isDoc(mimetype) Returns true if the mimetype is a document. (doc, docx, odt, ods, xlsx, etc) Parameters: Name Type Description mimetype string The mimetype Source: common/mimeCheck.ts, line 12 Returns: Type boolean isImage(mimetype) Returns true if the mimetype is an image Parameters: Name Type Description mimetype string The mimetype Source: common/mimeCheck.ts, line 47 Returns: Type boolean isMimetypeSupported(mimetype) Returns true if we support the mimetype Parameters: Name Type Description mimetype string The mimetype Source: common/mimeCheck.ts, line 72 Returns: Type boolean isPdf(mimetype) Returns true if the mimetype is a PDF Parameters: Name Type Description mimetype string The mimetype Source: common/mimeCheck.ts, line 3 Returns: Type boolean isZip(mimetype) Returns true if mimetype is a zip file. Does not include 7z, rar, etc. Parameters: Name Type Description mimetype string The mimetype Source: common/mimeCheck.ts, line 32 Returns: Type boolean &lt;async&gt; mkdirp(thepath) Creates a directory path Parameters: Name Type Description thepath Source: server/fsStuff.ts, line 57 &lt;async&gt; readFile(thePath) Promise version of readFile Parameters: Name Type Description thePath Source: server/fsStuff.ts, line 14 &lt;async&gt; rmFile(thePath) Promise version of unlink Parameters: Name Type Description thePath Source: server/fsStuff.ts, line 90 &lt;async&gt; rmFiles(files) Removes multiple files Parameters: Name Type Description files Source: server/fsStuff.ts, line 106 &lt;async&gt; streamsToTmpFiles(iStreams, tmpFolder) Streams multiple streams to tmp files Parameters: Name Type Description iStreams tmpFolder Source: server/fsStuff.ts, line 147 &lt;async&gt; streamToTmp(iStream, tmpFolder) Streams to a random filename in a tmp folder Parameters: Name Type Description iStream tmpFolder Source: server/fsStuff.ts, line 129 unzipper(zipReadStream, onFile) Unzips a zip file calling a callback for each file in the zip file. Parameters: Name Type Description zipReadStream Readable The readable zip file stream. onFile OnFileCallback Called for each file in the zip file. Source: server/unzipper.ts, line 16 Returns: Returns a promise when the zip file is complete. Type Promise.&lt;void&gt; &lt;async&gt; writeFile(thePath, theBuffer) Promise version of writeFile Parameters: Name Type Description thePath theBuffer Source: server/fsStuff.ts, line 23 &lt;async&gt; writeStream(fname, iStream) Promise version of file writer that writes a stream Parameters: Name Type Description fname iStream Source: server/fsStuff.ts, line 114 × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Classes Classes FileCleaner FileTypeReadStream SharedCache TimeoutCounter ZipReader × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream sidebar_label: Extras title: Extras Extra utilities Install yarn add @thx/extras × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"FileCleaner.html":{"id":"FileCleaner.html","title":"Class: FileCleaner","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Class: FileCleaner FileCleaner Class that records written files and cleans up after new FileCleaner() Source: server/FileCleaner.ts, line 22 Methods add(filename) Adds a file to be cleaned Parameters: Name Type Description filename Source: server/FileCleaner.ts, line 34 remove(filename) Removes a file to be cleaned Parameters: Name Type Description filename Source: server/FileCleaner.ts, line 43 &lt;async&gt; removeFiles() Removes files, first checking to make sure they exist Source: server/FileCleaner.ts, line 65 rename(a, b) Renames a file Parameters: Name Type Description a b Source: server/FileCleaner.ts, line 53 reset() Resets the file cleaner Source: server/FileCleaner.ts, line 82 × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"FileTypeReadStream.html":{"id":"FileTypeReadStream.html","title":"Class: FileTypeReadStream","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Class: FileTypeReadStream FileTypeReadStream Determines the mimetype of a stream. Grabs the minimum number of bytes required to determine the mimetype. new FileTypeReadStream() Source: server/FileTypeReadStream.ts, line 20 × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"SharedCache.html":{"id":"SharedCache.html","title":"Class: SharedCache","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Class: SharedCache SharedCache new SharedCache(redis, prefix, expire) Constructs a new SharedCache Parameters: Name Type Description redis prefix expire Source: server/SharedCache.ts, line 33 Methods &lt;async&gt; clear(key) Removes a key from the store Parameters: Name Type Description key Source: server/SharedCache.ts, line 108 Returns: True if they key exists and is cleared, otherwise false Type Promise.&lt;boolean&gt; &lt;async&gt; exists(key) Checks if the key exists in the store. Parameters: Name Type Description key Source: server/SharedCache.ts, line 97 Returns: Returns true if the key is found, otherwise false. Type Promise.&lt;boolean&gt; &lt;async&gt; get(key) Gets the value of a key. Returns null if the key does not exist. Parameters: Name Type Description key Source: server/SharedCache.ts, line 86 Returns: The value or null. Type Promise.&lt;*&gt; &lt;async&gt; set(key, data, expire) Sets a key value pair with optional expiry (in seconds). Parameters: Name Type Description key data expire Source: server/SharedCache.ts, line 68 Returns: Type Promise.&lt;*&gt; × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"TimeoutCounter.html":{"id":"TimeoutCounter.html","title":"Class: TimeoutCounter","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Class: TimeoutCounter TimeoutCounter new TimeoutCounter(timeout) Initialize a TimeoutCounter with ms delay. Parameters: Name Type Default Description timeout 1000 Source: server/TimeoutCounter.ts, line 15 Methods add() Increase the counter by one. This also resets the timer. Source: server/TimeoutCounter.ts, line 40 cancel() Cancel the timeout counter and reset it. Source: server/TimeoutCounter.ts, line 70 remove() Decrease the counter by one. This also resets the timer. When the last item is removed, it fires the 'finish' event. Source: server/TimeoutCounter.ts, line 52 × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "},"ZipReader.html":{"id":"ZipReader.html","title":"Class: ZipReader","body":" Documentation Classes FileCleanerFileTypeReadStreamSharedCacheTimeoutCounterZipReader Global copyFilefileExistsisDocisImageisMimetypeSupportedisPdfisZipmkdirpreadFilermFilermFilesstreamsToTmpFilesstreamToTmpunzipperwriteFilewriteStream Class: ZipReader ZipReader new ZipReader(fs, filename) Used to read zip files from any FS like system. Parameters: Name Type Description fs filename Source: server/ZipReader.ts, line 16 × Search results Close Documentation generated by JSDoc 3.6.2 on 2019-08-14T10:35:14-05:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
